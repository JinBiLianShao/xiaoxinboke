title: ã€ä¸€å‘¨ä¸€ç®—æ³•ã€‘ç¬¬ä¸‰å‘¨ï¼š å½’å¹¶æ’åº Â· æ€è€ƒé¢˜ä¸ç»ƒä¹ è¯¦è§£
author: è¿æ€é‘«
tags:
  - ç®—æ³•
  - C++
  - æ•™ç¨‹
  - å½’å¹¶ç®—æ³•
categories:
  - ä¸€å‘¨ä¸€ç®—æ³•
  - ''
date: 2025-10-27 15:40:00
---
# ğŸ§  å½’å¹¶æ’åº Â· æ€è€ƒé¢˜ä¸ç»ƒä¹ è¯¦è§£

> "ç†è§£é€’å½’çš„æœ€å¥½æ–¹å¼ï¼Œå°±æ˜¯äº²æ‰‹ç”»å‡ºé€’å½’æ ‘ï¼›ç†è§£åˆå¹¶çš„æœ€å¥½æ–¹å¼ï¼Œå°±æ˜¯äº²æ‰‹å®ç°é“¾è¡¨ç‰ˆæœ¬ã€‚"

---

## ğŸ§© æ€è€ƒé¢˜ä¸€ï¼šé“¾è¡¨ä¸Šçš„å½’å¹¶æ’åº

### â“ é—®é¢˜
**ä¸ºä»€ä¹ˆå½’å¹¶æ’åºåœ¨é“¾è¡¨æ’åºä¸­è¡¨ç°éå¸¸ä¼˜ç§€ï¼Ÿ**

### ğŸ’¡ è¯¦è§£

**æ ¸å¿ƒç­”æ¡ˆ**ï¼šå› ä¸ºé“¾è¡¨çš„åˆå¹¶æ“ä½œå¯ä»¥åœ¨ $O(1)$ çš„é¢å¤–ç©ºé—´å†…å®Œæˆï¼Œé¿å…äº†æ•°ç»„ç‰ˆæœ¬ä¸­ $O(n)$ çš„ç©ºé—´å¼€é”€ã€‚

è®©æˆ‘ä»¬é€šè¿‡ä»£ç å¯¹æ¯”æ¥ç†è§£ï¼š

#### ğŸ”¹ æ•°ç»„ç‰ˆæœ¬çš„åˆå¹¶ï¼ˆéœ€è¦é¢å¤–ç©ºé—´ï¼‰

```cpp
// æ•°ç»„åˆå¹¶ï¼šéœ€è¦ O(n) é¢å¤–ç©ºé—´
void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);  // ğŸš¨ é¢å¤–ç©ºé—´å¼€é”€
    // ... åˆå¹¶é€»è¾‘
}
```

#### ğŸ”¹ é“¾è¡¨ç‰ˆæœ¬çš„åˆå¹¶ï¼ˆåŸåœ°æ“ä½œï¼‰

```cpp
// é“¾è¡¨èŠ‚ç‚¹å®šä¹‰
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// é“¾è¡¨åˆå¹¶ï¼šO(1) é¢å¤–ç©ºé—´
ListNode* mergeLists(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);        // ğŸ¯ ä»…ä½¿ç”¨ä¸€ä¸ªå“¨å…µèŠ‚ç‚¹
    ListNode* tail = &dummy;
    
    while (l1 && l2) {
        if (l1->val <= l2->val) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }
    
    tail->next = l1 ? l1 : l2;
    return dummy.next;
}
```

### ğŸ“Š æ€§èƒ½å¯¹æ¯”

| ç‰¹æ€§ | æ•°ç»„ç‰ˆæœ¬ | é“¾è¡¨ç‰ˆæœ¬ |
|------|----------|----------|
| ç©ºé—´å¤æ‚åº¦ | $O(n)$ | $O(\log n)$ï¼ˆé€’å½’æ ˆï¼‰ |
| åˆå¹¶æ“ä½œ | éœ€è¦æ‹·è´æ•°æ® | ç›´æ¥ä¿®æ”¹æŒ‡é’ˆ |
| ç¼“å­˜å‹å¥½æ€§ | âœ… å¥½ | âŒ å·®ï¼ˆå†…å­˜ä¸è¿ç»­ï¼‰ |
| é€‚ç”¨åœºæ™¯ | éšæœºè®¿é—®éœ€æ±‚ | åŠ¨æ€æ•°æ®ç»“æ„ |

### ğŸ¯ LeetCode å®æˆ˜

```cpp
// LeetCode #148 - é“¾è¡¨æ’åº
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (!head || !head->next) return head;
        
        // å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹
        ListNode* slow = head;
        ListNode* fast = head->next;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        // åˆ†å‰²é“¾è¡¨
        ListNode* mid = slow->next;
        slow->next = nullptr;
        
        // é€’å½’æ’åº
        ListNode* left = sortList(head);
        ListNode* right = sortList(mid);
        
        // åˆå¹¶
        return mergeLists(left, right);
    }
    
private:
    ListNode* mergeLists(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* tail = &dummy;
        
        while (l1 && l2) {
            if (l1->val <= l2->val) {
                tail->next = l1;
                l1 = l1->next;
            } else {
                tail->next = l2;
                l2 = l2->next;
            }
            tail = tail->next;
        }
        
        tail->next = l1 ? l1 : l2;
        return dummy.next;
    }
};
```

---

## ğŸ” æ€è€ƒé¢˜äºŒï¼šé€’å½’æ·±åº¦è®¡ç®—

### â“ é—®é¢˜
**è‹¥æ•°ç»„é•¿åº¦æ˜¯ 1024ï¼Œé€’å½’æ·±åº¦æ˜¯å¤šå°‘ï¼Ÿ**

### ğŸ’¡ è¯¦è§£

**ç›´æ¥è®¡ç®—**ï¼š
$$
\log_2 1024 = 10
$$

**é€’å½’æ ‘å¯è§†åŒ–**ï¼š
```
å±‚çº§ 0: [0..1023]        (å¤§å°: 1024)
å±‚çº§ 1: [0..511] [512..1023]  (å¤§å°: 512)
å±‚çº§ 2: [0..255] [256..511] ... (å¤§å°: 256)
...
å±‚çº§ 10: [0] [1] [2] ... [1023] (å¤§å°: 1)
```

**ä»£ç éªŒè¯**ï¼š
```cpp
int calculateDepth(int n, int currentDepth = 0) {
    if (n <= 1) return currentDepth;
    return calculateDepth(n / 2, currentDepth + 1);
}

// æµ‹è¯•
cout << "1024çš„é€’å½’æ·±åº¦: " << calculateDepth(1024) << endl;
// è¾“å‡º: 1024çš„é€’å½’æ·±åº¦: 10
```

### ğŸ¯ é€šç”¨å…¬å¼

å¯¹äºé•¿åº¦ä¸º $n$ çš„æ•°ç»„ï¼Œå½’å¹¶æ’åºé€’å½’æ·±åº¦ä¸ºï¼š
$$
\text{æ·±åº¦} = \lceil \log_2 n \rceil
$$

| æ•°ç»„é•¿åº¦ | é€’å½’æ·±åº¦ | é€’å½’è°ƒç”¨æ¬¡æ•° |
|---------|----------|-------------|
| 16 | 4 | 31 |
| 1024 | 10 | 2047 |
| 1,048,576 | 20 | ~2ç™¾ä¸‡ |

---

## âš¡ æ€è€ƒé¢˜ä¸‰ï¼šè¿­ä»£ç‰ˆå½’å¹¶æ’åº

### â“ é—®é¢˜
**è¯·å°è¯•å®ç°è¿­ä»£ç‰ˆï¼ˆéé€’å½’ç‰ˆï¼‰å½’å¹¶æ’åº**

### ğŸ’¡ è¯¦è§£

è¿­ä»£ç‰ˆæœ¬é¿å…äº†é€’å½’è°ƒç”¨ï¼Œä½¿ç”¨å¾ªç¯è‡ªåº•å‘ä¸Šåˆå¹¶ï¼š

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void iterativeMergeSort(std::vector<int>& arr) {
    int n = arr.size();
    std::vector<int> temp(n);
    
    // ğŸ¯ ä»å¤§å°ä¸º1çš„å­æ•°ç»„å¼€å§‹ï¼Œæ¯æ¬¡ç¿»å€
    for (int size = 1; size < n; size *= 2) {
        // éå†æ‰€æœ‰æˆå¯¹çš„å­æ•°ç»„
        for (int leftStart = 0; leftStart < n; leftStart += 2 * size) {
            int mid = std::min(leftStart + size - 1, n - 1);
            int rightEnd = std::min(leftStart + 2 * size - 1, n - 1);
            
            // åˆå¹¶ arr[leftStart..mid] å’Œ arr[mid+1..rightEnd]
            iterativeMerge(arr, temp, leftStart, mid, rightEnd);
        }
    }
}

void iterativeMerge(std::vector<int>& arr, std::vector<int>& temp, 
                   int left, int mid, int right) {
    int i = left, j = mid + 1, k = left;
    
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    
    // æ‹·è´å›åŸæ•°ç»„
    for (int idx = left; idx <= right; ++idx) {
        arr[idx] = temp[idx];
    }
}

// æµ‹è¯•
int main() {
    std::vector<int> arr = {38, 27, 43, 3, 9, 82, 10};
    iterativeMergeSort(arr);
    
    std::cout << "è¿­ä»£ç‰ˆæ’åºç»“æœ: ";
    for (int num : arr) std::cout << num << " ";
    std::cout << std::endl;
}
```

### ğŸ”„ æ‰§è¡Œè¿‡ç¨‹ç¤ºä¾‹

```
åˆå§‹: [38, 27, 43, 3, 9, 82, 10]

size=1: åˆå¹¶ç›¸é‚»å…ƒç´ 
[27, 38] [3, 43] [9, 82] [10]

size=2: åˆå¹¶å¤§å°ä¸º2çš„å—
[3, 27, 38, 43] [9, 10, 82]

size=4: åˆå¹¶å¤§å°ä¸º4çš„å—
[3, 9, 10, 27, 38, 43, 82]
```

### ğŸ“Š é€’å½’ vs è¿­ä»£å¯¹æ¯”

| ç‰¹æ€§ | é€’å½’ç‰ˆæœ¬ | è¿­ä»£ç‰ˆæœ¬ |
|------|----------|----------|
| ä»£ç å¯è¯»æ€§ | âœ… æ›´ç›´è§‚ | âŒ ç¨å¤æ‚ |
| ç©ºé—´å¼€é”€ | $O(n + \log n)$ | $O(n)$ |
| å‡½æ•°è°ƒç”¨ | æœ‰é€’å½’å¼€é”€ | æ— é€’å½’å¼€é”€ |
| ç¼“å­˜å‹å¥½ | âŒ å·® | âœ… æ›´å¥½ |

---

## ğŸ¯ æ€è€ƒé¢˜å››ï¼šå•ç¼“å†²åŒºåˆå¹¶ä¼˜åŒ–

### â“ é—®é¢˜
**ä½ èƒ½åœ¨ `merge()` å‡½æ•°ä¸­åªç”¨ä¸€ä¸ªç¼“å†²åŒºå®Œæˆå·¦å³åˆå¹¶å—ï¼Ÿ**

### ğŸ’¡ è¯¦è§£

**æŒ‘æˆ˜**ï¼šä¼ ç»Ÿçš„åˆå¹¶éœ€è¦ä¸¤ä¸ªä¸´æ—¶æ•°ç»„ L å’Œ Rï¼Œèƒ½å¦åªç”¨ä¸€ä¸ªï¼Ÿ

**è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨å•ä¸ªç¼“å†²åŒºï¼Œä½†éœ€è¦å·§å¦™çš„æ‹·è´ç­–ç•¥ï¼š

```cpp
void optimizedMerge(std::vector<int>& arr, int left, int mid, int right) {
    // ğŸ¯ åªä½¿ç”¨ä¸€ä¸ªä¸´æ—¶ç¼“å†²åŒº
    std::vector<int> buffer(arr.begin() + left, arr.begin() + right + 1);
    
    int n1 = mid - left + 1;    // å·¦åŠéƒ¨åˆ†é•¿åº¦
    int i = 0, j = n1, k = left;  // i: å·¦åŠæŒ‡é’ˆ, j: å³åŠæŒ‡é’ˆ, k: åŸæ•°ç»„æŒ‡é’ˆ
    
    while (i < n1 && j < buffer.size()) {
        if (buffer[i] <= buffer[j]) {
            arr[k++] = buffer[i++];
        } else {
            arr[k++] = buffer[j++];
        }
    }
    
    // å¤„ç†å‰©ä½™å…ƒç´ 
    while (i < n1) arr[k++] = buffer[i++];
    while (j < buffer.size()) arr[k++] = buffer[j++];
}
```

### ğŸ”„ åˆå¹¶è¿‡ç¨‹æ¼”ç¤º

```
åŸæ•°ç»„: [3, 27, 38, 43, 9, 10, 82]
left=0, mid=3, right=6

ç¼“å†²åŒº: [3, 27, 38, 43, 9, 10, 82]
        â†‘i        â†‘j

æ¯”è¾ƒ buffer[i]=3 vs buffer[j]=9 â†’ å–3
æ¯”è¾ƒ buffer[i]=27 vs buffer[j]=9 â†’ å–9
æ¯”è¾ƒ buffer[i]=27 vs buffer[j]=10 â†’ å–10
æ¯”è¾ƒ buffer[i]=27 vs buffer[j]=82 â†’ å–27
...
æœ€ç»ˆ: [3, 9, 10, 27, 38, 43, 82]
```

### ğŸ“ˆ ç©ºé—´ä¼˜åŒ–æ•ˆæœ

| ç‰ˆæœ¬ | ä¸´æ—¶ç©ºé—´ | è¯´æ˜ |
|------|----------|------|
| ä¼ ç»Ÿç‰ˆæœ¬ | $2 \times \frac{n}{2} = n$ | ä¸¤ä¸ªä¸´æ—¶æ•°ç»„ |
| ä¼˜åŒ–ç‰ˆæœ¬ | $n$ | ä¸€ä¸ªç¼“å†²åŒº |
| é“¾è¡¨ç‰ˆæœ¬ | $O(1)$ | ä»…å“¨å…µèŠ‚ç‚¹ |

**è™½ç„¶ç©ºé—´å¤æ‚åº¦ä»æ˜¯ $O(n)$ï¼Œä½†ï¼š**
- å‡å°‘å†…å­˜åˆ†é…æ¬¡æ•°
- ä»£ç æ›´ç®€æ´
- å®é™…æ€§èƒ½å¯èƒ½æ›´å¥½

---

## ğŸš€ æ‰©å±•ç»ƒä¹ 

### ğŸ§© ç»ƒä¹ 1ï¼šå½’å¹¶æ’åºçš„æ€§èƒ½æµ‹è¯•

```cpp
#include <chrono>
#include <random>

void performanceTest() {
    for (int size : {1000, 10000, 100000, 1000000}) {
        std::vector<int> arr(size);
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(1, size);
        
        for (int i = 0; i < size; ++i) {
            arr[i] = dis(gen);
        }
        
        auto start = std::chrono::high_resolution_clock::now();
        mergeSort(arr, 0, arr.size() - 1);
        auto end = std::chrono::high_resolution_clock::now();
        
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "å¤§å° " << size << ": " << duration.count() << " ms" << std::endl;
    }
}
```

### ğŸ§© ç»ƒä¹ 2ï¼šå½’å¹¶æ’åºçš„ç¨³å®šç‰ˆæœ¬

ç¡®ä¿åœ¨ç›¸ç­‰æ—¶ä¿æŒåŸå§‹é¡ºåºï¼š

```cpp
void stableMerge(std::vector<int>& arr, int left, int mid, int right) {
    // å…³é”®ï¼šä½¿ç”¨ <= è€Œä¸æ˜¯ < æ¥ä¿æŒç¨³å®šæ€§
    if (L[i] <= R[j]) {  // ğŸ¯ ç›¸ç­‰æ—¶ä¼˜å…ˆå–å·¦è¾¹çš„
        arr[k++] = L[i++];
    } else {
        arr[k++] = R[j++];
    }
}
```

### ğŸ§© ç»ƒä¹ 3ï¼šå¤šè·¯å½’å¹¶æ’åº

```cpp
// ä¸‰è·¯å½’å¹¶æ’åº
void threeWayMergeSort(std::vector<int>& arr, int left, int right) {
    if (right - left < 2) return;
    
    int third1 = left + (right - left) / 3;
    int third2 = left + 2 * (right - left) / 3;
    
    threeWayMergeSort(arr, left, third1);
    threeWayMergeSort(arr, third1 + 1, third2);
    threeWayMergeSort(arr, third2 + 1, right);
    
    threeWayMerge(arr, left, third1, third2, right);
}
```

---

## ğŸ’ æ€»ç»“

é€šè¿‡è¿™å››ä¸ªæ€è€ƒé¢˜ï¼Œæˆ‘ä»¬æ·±å…¥ç†è§£äº†ï¼š

1. **æ•°æ®ç»“æ„é€‚åº”æ€§**ï¼šé“¾è¡¨ä¸Šçš„å½’å¹¶æ’åºç©ºé—´æ•ˆç‡æ›´é«˜
2. **é€’å½’æœ¬è´¨**ï¼šæ·±åº¦ä¸æ•°æ®è§„æ¨¡çš„å¯¹æ•°å…³ç³»
3. **ç®—æ³•å˜å½¢**ï¼šè¿­ä»£ç‰ˆæœ¬é¿å…é€’å½’å¼€é”€
4. **ç©ºé—´ä¼˜åŒ–**ï¼šå•ç¼“å†²åŒºåˆå¹¶çš„æŠ€å·§

> ğŸ¯ "ä¼˜ç§€çš„ç®—æ³•å·¥ç¨‹å¸ˆä¸ä»…ä¼šä½¿ç”¨æ ‡å‡†å®ç°ï¼Œæ›´æ‡‚å¾—æ ¹æ®å…·ä½“åœºæ™¯é€‰æ‹©æœ€ä¼˜å˜ç§ã€‚"

è¿™äº›æ·±å…¥ç†è§£ä¸ºæˆ‘ä»¬å­¦ä¹ æ›´å¤æ‚çš„åˆ†æ²»ç®—æ³•ï¼ˆå¦‚å¿«é€Ÿæ’åºã€å¤–éƒ¨æ’åºï¼‰å¥ å®šäº†åšå®åŸºç¡€ã€‚

---
